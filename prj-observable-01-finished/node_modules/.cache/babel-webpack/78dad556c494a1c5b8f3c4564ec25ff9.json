{"ast":null,"code":"import _assertThisInitialized from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/momodoujammeh/Developement/angular/Assignments/prj-observable-01-finished/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nvar BufferTimeOperator = /*#__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _classCallCheck(this, BufferTimeOperator);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(BufferTimeOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n  }]);\n\n  return BufferTimeOperator;\n}();\n\nvar Context = /*#__PURE__*/_createClass(function Context() {\n  _classCallCheck(this, Context);\n\n  this.buffer = [];\n});\n\nvar BufferTimeSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(BufferTimeSubscriber, _Subscriber);\n\n  var _super = _createSuper(BufferTimeSubscriber);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this;\n\n    _classCallCheck(this, BufferTimeSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _assertThisInitialized(_this),\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  _createClass(BufferTimeSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var contexts = this.contexts;\n      var len = contexts.length;\n      var filledBufferContext;\n\n      for (var i = 0; i < len; i++) {\n        var context = contexts[i];\n        var buffer = context.buffer;\n        buffer.push(value);\n\n        if (buffer.length == this.maxBufferSize) {\n          filledBufferContext = context;\n        }\n      }\n\n      if (filledBufferContext) {\n        this.onBufferFull(filledBufferContext);\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.contexts.length = 0;\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_error\", this).call(this, err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var contexts = this.contexts,\n          destination = this.destination;\n\n      while (contexts.length > 0) {\n        var context = contexts.shift();\n        destination.next(context.buffer);\n      }\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_complete\", this).call(this);\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.contexts = null;\n    }\n  }, {\n    key: \"onBufferFull\",\n    value: function onBufferFull(context) {\n      this.closeContext(context);\n      var closeAction = context.closeAction;\n      closeAction.unsubscribe();\n      this.remove(closeAction);\n\n      if (!this.closed && this.timespanOnly) {\n        context = this.openContext();\n        var bufferTimeSpan = this.bufferTimeSpan;\n        var timeSpanOnlyState = {\n          subscriber: this,\n          context: context,\n          bufferTimeSpan: bufferTimeSpan\n        };\n        this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n      }\n    }\n  }, {\n    key: \"openContext\",\n    value: function openContext() {\n      var context = new Context();\n      this.contexts.push(context);\n      return context;\n    }\n  }, {\n    key: \"closeContext\",\n    value: function closeContext(context) {\n      this.destination.next(context.buffer);\n      var contexts = this.contexts;\n      var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n      if (spliceIndex >= 0) {\n        contexts.splice(contexts.indexOf(context), 1);\n      }\n    }\n  }]);\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    let length = arguments.length;\n    let scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    let bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    let maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nclass BufferTimeOperator {\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n}\nclass Context {\n    constructor() {\n        this.buffer = [];\n    }\n}\nclass BufferTimeSubscriber extends Subscriber {\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        super(destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        const context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            const closeState = { subscriber: this, context };\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        let filledBufferContext;\n        for (let i = 0; i < len; i++) {\n            const context = contexts[i];\n            const buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    }\n    _error(err) {\n        this.contexts.length = 0;\n        super._error(err);\n    }\n    _complete() {\n        const { contexts, destination } = this;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.contexts = null;\n    }\n    onBufferFull(context) {\n        this.closeContext(context);\n        const closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            const bufferTimeSpan = this.bufferTimeSpan;\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    }\n    openContext() {\n        const context = new Context();\n        this.contexts.push(context);\n        return context;\n    }\n    closeContext(context) {\n        this.destination.next(context.buffer);\n        const contexts = this.contexts;\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n    const subscriber = state.subscriber;\n    const prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n    const context = subscriber.openContext();\n    const action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    const { subscriber, context } = arg;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"module"}